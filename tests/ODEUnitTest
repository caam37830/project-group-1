"""
Implement ODE Unit Tests
"""

import unittest
import numpy as np
from scipy.integrate import solve_ivp

#NEED TO WORK ON IMPORTING OTHER FILE
#import sys  
#sys.path.append('**/Git/Serpents-n-Pythons/sir/')  
#from ODE_Function import * #scriptName without .py extension  

#import sys, os
#__file__ = 'ODE_Scripts.ipynb'
#sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'sir'))
#import ODE_Function


class TestODEs(unittest.TestCase):
                  
    def test_partials_ODE(self):
        '''
        This will test that x dot, y dot, and z dot are sufficiently close to the solution's respective discretized results
        '''
        h = 300 #Time Step - days
        k = 2*h #Time Step - half days
        y_init = np.array([0.99999, 0.00001, 0]) #Initial Condition
        tspan = np.linspace(0, 300, k + 2) #300 days, halfday-steps
        
        b = .30 #Infection Rate
        k = .20 #Removal Rate
        c = [b, k] #Array of constants (referenced in derivative function)
        
        def f(t, SIR, c): #derivative function
            dSIRdt = [-1 * c[0] * SIR[0] * SIR[1],# S dot
                    c[0] * SIR[0] * SIR[1] - c[1] * SIR[1],# I dot 
                    c[1] * SIR[1]] #R dot
            return dSIRdt
        
        sol = solve_ivp(lambda t, SIR: f(t, SIR, c), \
                [tspan[0], tspan[-1]], SIR_init, t_eval=tspan)
        
        derivatives = [] #Building Derivatives
        for i in range(soldefault.t.shape[1] - 1):
            upper = soldefault.y[:,i+1]
            lower = soldefault.y[:,i]
            finite_difference = (upper - lower)/k
            
            derivatives.append(finite_difference)
               
        x_array = np.array(soldefault.y[0,:-1]) #Make these np arrays for element-wise subtraction  
        y_array = np.array(soldefault.y[1,:-1]) #Make these np arrays for element-wise subtraction
        z_array = np.array(soldefault.y[2,:-1]) #Make these np arrays for element-wise subtraction
        
        #xdot
        xderivative_array = np.array(derivatives[0,:]) #Finite Differences Derivatives
        x_dot_function = -1 * b * x_array * y_array #Solution results plugged into differential equation
        xdifference = x_array - xderivative_array #Difference should be zero
        
        for i in range(xdifference.shape[0]): #For all solution points
            self.assertTrue(np.abs(xdifference[i]) < .005) #Test checks if absolute difference is close enough to 0
           
        #ydot
        yderivative_array = np.array(derivatives[1,:]) #Finite Differences Derivatives
        y_dot_function = b * x_array * y_array - k * y_array #Solution results plugged into differential equation
        ydifference = y_array - yderivative_array #Difference should be zero
        
        for i in range(ydifference.shape[0]): #For all solution points
            self.assertTrue(np.abs(ydifference[i]) < .005) #Test checks if absolute difference is close enough to 0
            
        #zdot
        zderivative_array = np.array(derivatives[2,:]) #Finite Differences Derivatives
        z_dot_function = k * y_array #Solution results plugged into differential equation
        zdifference = z_array - zderivative_array #Difference should be zero
        
        for i in range(zdifference.shape[0]): #For all solution points
            self.assertTrue(np.abs(zdifference[i]) < .005) #Test checks if absolute difference is close enough to 0    
            
    def test_sums(self):
        '''
        This will test that x dot, y dot, and z dot are sufficiently close to the solution's respective discretized results
        '''
        h = 300 #Time Step - days
        k = 2*h #Time Step - half days
        y_init = np.array([0.99999, 0.00001, 0]) #Initial Condition
        tspan = np.linspace(0, 300, k + 2) #300 days, halfday-steps
        
        b = .30 #Infection Rate
        k = .20 #Removal Rate
        c = [b, k] #Array of constants (referenced in derivative function)
        
        def f(t, SIR, c): #derivative function
            dSIRdt = [-1 * c[0] * SIR[0] * SIR[1],# S dot
                    c[0] * SIR[0] * SIR[1] - c[1] * SIR[1],# I dot 
                    c[1] * SIR[1]] #R dot
            return dSIRdt
        
        sol = solve_ivp(lambda t, SIR: f(t, SIR, c), \
                [tspan[0], tspan[-1]], SIR_init, t_eval=tspan)
        
        x_array = np.array(soldefault.y[0,:-1]) #Make these np arrays for element-wise adddition  
        y_array = np.array(soldefault.y[1,:-1]) #Make these np arrays for element-wise addition
        z_array = np.array(soldefault.y[2,:-1]) #Make these np arrays for element-wise addition
            
        sum_array = x_array + y_array + z_array #This should equal one
        ones = np.ones(sum_array(shape)) #Construct actual ones
        diff = ones - sum_array #This should be close to zero
        self.assertTrue(np.abs(np.maximum(diff)) < .05 ) #We test to see if this is close enough to zero

    def test_derivative_sums(self): 
        '''
        This will test that x dot, y dot, and z dot are sufficiently close to the solution's respective discretized results
        '''
        h = 300 #Time Step - days
        k = 2*h #Time Step - half days
        y_init = np.array([0.99999, 0.00001, 0]) #Initial Condition
        tspan = np.linspace(0, 300, k + 2) #300 days, halfday-steps
        
        b = .30 #Infection Rate
        k = .20 #Removal Rate
        c = [b, k] #Array of constants (referenced in derivative function)
        
        def f(t, SIR, c): #derivative function
            dSIRdt = [-1 * c[0] * SIR[0] * SIR[1],# S dot
                    c[0] * SIR[0] * SIR[1] - c[1] * SIR[1],# I dot 
                    c[1] * SIR[1]] #R dot
            return dSIRdt
        
        sol = solve_ivp(lambda t, SIR: f(t, SIR, c), \
                [tspan[0], tspan[-1]], SIR_init, t_eval=tspan)
        
        x_array = np.array(soldefault.y[0,:-1]) #Make these np arrays for element-wise adddition  
        y_array = np.array(soldefault.y[1,:-1]) #Make these np arrays for element-wise addition
        z_array = np.array(soldefault.y[2,:-1]) #Make these np arrays for element-wise addition

        derivatives = [] #Building Derivatives
        for i in range(soldefault.t.shape[1] - 1):
            upper = soldefault.y[:,i+1]
            lower = soldefault.y[:,i]
            finite_difference = (upper - lower)/k
            
            derivatives.append(finite_difference)
            
        x_array = np.array(soldefault.y[0,:-1]) #Make these np arrays for element-wise subtraction  
        y_array = np.array(soldefault.y[1,:-1]) #Make these np arrays for element-wise subtraction
        z_array = np.array(soldefault.y[2,:-1]) #Make these np arrays for element-wise subtraction
        
        #xdot
        xderivative_array = np.array(derivatives[0,:]) #Finite Differences Derivatives
        
        #ydot
        yderivative_array = np.array(derivatives[1,:]) #Finite Differences Derivatives

        #zdot
        zderivative_array = np.array(derivatives[2,:]) #Finite Differences Derivatives
        
        sum_array = xderivative_array + yderivative_array + zderivative_array #This should be close to zero
        self.assertTrue(np.abs(np.maximum(sum_array)) < .05 ) #We test to see if this is close enough to zero